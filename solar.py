#!/usr/bin/env python3
""" DESCRIPCION DEL PROGRAMA, librerias, PURPOSE, MIS DATOS"""
#-------------------------------------------------------------------------------
# Title: solar.py
# Author: Andres Gutierrez Castano
# PRID: GUTI01304
# 
# Programming Language: Python v3.4.2
# Program Description: The following program calculates the amount of 
#	electricity by solar panels. The program reads input from a file
#	provided by the	terminal which contains two numbers, the first one is an
#	integer starting from 0 that indicates the number of the day in which
#	the measure was taken,and the second one is a float containing the 
#	electrical meausurement. It is important to state that the file is
#	missing some inputs, so this had to be generated. As well the file
#	contains comments that should be ignored.
#
#
#-------------------------------------------------------------------------------

import sys, string, math, matplotlib.pyplot as plt, numpy as np

# Definition of function mean, this function calculates the mean value in
# a dictionary given as a parameter.

def mean(d):
	avg = 0
	for key,value in d.items():
		avg += value
	return avg / len(d)

#Definition of function sd, this function calculates the standard deviation
# in a dictionary providing as parameters the dictionary and its mean(avg) value

def sd(d, avg):
	s = 0
	for key,value in d.items():
		s += pow(value - avg,2)
	return math.sqrt(s/len(d))

# Definition of function RMSE, this function calculates the root mean square
# error between two lists of values with equal sizes.

def RMSE(l1,l2):
	result = 0
	if(len(l1) == len(l2)):
		for i in range(0,len(l1)):
			result += math.pow((l1[i] - l2[i]),2)
		result = result/len(l1)
	return math.sqrt(result)
#-------------------------------------------------------------------------------
# This section verifies if the user provides the file name via terminal, 
# if it is not provided, the correct way of using the program will be printed.
#-------------------------------------------------------------------------------

if(len(sys.argv) < 2):
	print("Usage: solar.py <filename>",file=sys.stderr)
	exit(1)

# Dictionary declaration, this dictionary holds the sanitized input from the
# file provided in the terminal.
dicReadings = {} 

# Use try-except to open the file in order to protect it from abnormal 
# situations.

try:
	# Opens the file provided by the terminal with reading mode and names
	# the file stream as f
	with open(sys.argv[1],'r') as f:
		# Iterates the file reading line by line
		for line in f:
			# Conditional used to ignore comments and lines smaller
			# than 2 in length.
			if ('#' not in line and len(line) > 1):
				# use temporal array to split the
				# line to get each column, strips \n as well.
				line = line.rstrip()
				temp = line.split(' ') 
				# First column is the day number and 
				# second the recording.
				dicReadings[int(temp[0])] = float(temp[1])

# When there is a problem with the file, the except is executed.	
except:
	# Prints File Problem to the terminal and exits with a status 2.
	print("File Problem", file=sys.stderr)
	exit(2)

#-------------------------------------------------------------------------------
# This sections calculates the amounts generated per day
# by iterating through the dictionary that holds the sanitized input. 
# When the key is equal to the iterator it means that the data exists, therefore
# the calculation of the amount generated is the substraction between the days.
#
# When the key and the iterator have different values, the calculation considers
# the mean amount generated by last value and the first value of the gap 
# and writes this value to all the days in the gap.
#
# ex: if the dictionary holds values until the day 125 and it skips to 129
#     the calculation of the generated values in the gap between 125 and 129
#     is calculated by substracting the measure of the day 125 from the measure
#     of 129 and then diving it by the difference of days. This part of the code
#     is shown from lines 101 to 103.
#-------------------------------------------------------------------------------


genElec = {}
it = 1
for key in list(dicReadings.keys())[1:]:
	if(key == it):
		genElec[it] = dicReadings[it] - dicReadings[it-1]
	
	# In this case there is no measure for the day so we find an avg for 
	# the amount generated
	else:
		for i in range(it,key+1):
			genElec[i] = ((dicReadings[key] - dicReadings[it-1])/ 
					(key - (it - 1)))
		it = key	
	it += 1

#Print mean amount generated per day
print("\nMean amount generated:")
print(mean(genElec))

#Print min amount generated and day/s
print("\nMinimum amount generated: (day, amount)")
minValue = min(genElec.values())
for key,value in genElec.items():
	if(minValue == value):
		print(key, value)

#Print max amount generated and day/s
print("\nMaximum amount generated: (day, amount)")
maxValue = max(genElec.values())
for key,value in genElec.items():
	if(maxValue == value):
		print(key,value)

#Split into chunks of 30 days and calculate mean and std dev per chunk
listGen = []
d= {}
c=0
for key,value in genElec.items():
	d[key] = value
	c += 1
	if(c == 30):
		listGen.append(d)
		d={}
		c=0
	if(key == len(genElec)):
		listGen.append(d)

#print mean and stdeviation per group of 30:
print("\n--------Mean and Std.Deviation per chunk of 30 data--------")
c = 1
meanChunks = []
sdChunks = []
for i in listGen:
	print("\nChunk %d" % c)
	print("Mean: %f" % mean(i))
	meanChunks.append(mean(i))	
	print("Standard Deviation: %f" % sd(i,mean(i)))
	sdChunks.append(sd(i,mean(i)))
	c += 1
#Pyplot settings
#plot
plt.grid(True)
plt.xlabel('Chunk')
plt.ylabel('Mean Amount Generated')


#Plot mean amount for each 30 day chunk	

plt.plot(list(range(1,c)),meanChunks, color = 'k')

#Plot mean amount plus one std deviation
meanPlusSD = []
for i in range(0,len(meanChunks)):
	meanPlusSD.append(meanChunks[i] + sdChunks[i])
plt.plot(list(range(1,c)),meanPlusSD, color = 'r')

#Plot mean amount minus one std deviation
meanMinusSD = []
for i in range(0,len(meanChunks)):
	meanMinusSD.append(meanChunks[i] - sdChunks[i])
plt.plot(list(range(1,c)),meanMinusSD, color = 'r')

#Plot function that looks like data (sine)
x = np.linspace(-7,50)

#Save values in a list for later calculation of RMSE
funValues = []
for i in range(1,len(meanChunks)+1):
	funValues.append(7*np.sin(.5*i) + 7)
		
plt.plot(7*np.sin(.5*x) + 7, color = 'g')
plt.show()

# Root mean square error calculation
print("------Calculation of RMSE------")
print(RMSE(meanChunks,funValues))
